<!DOCTYPE HTML>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="viewport" content= "user-scalable=no,initial-scale=1.0,	 maximum-scale=1.0">

<script id="shader-vs-2D" type="x-shader/x-vertex"> 
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;

    uniform float xOld;
    uniform float yOld;
    uniform float xNew;
    uniform float yNew;
    uniform float xLim;
    uniform float yLim;

    varying vec2 vTextureCoord;

    void main(void) {
        vec2 newVertexPosition = aVertexPosition;
        vec2 newTextureCoord   = aTextureCoord;
        if(((xOld != xNew) || (yOld != yNew)) 
                && (aVertexPosition.x > -1.0) && (aVertexPosition.x < 1.0)
                && (aVertexPosition.y > -1.0) && (aVertexPosition.y < 1.0)) {
            newVertexPosition = vec2(-1.0 + (2.0*xNew/xLim), -1.0 + (2.0*(yLim - yNew)/yLim));
            //newTextureCoord = vec2(0.0 + (xNew/xLim), 0.0 + (yNew/yLim));
        }

        gl_Position = vec4(newVertexPosition, 0.0, 1.0);
        vTextureCoord = newTextureCoord;
    }
</script>

<script id="shader-vs-1D" type="x-shader/x-vertex"> 
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;

    uniform float xOld;
    uniform float yOld;
    uniform float xNew;
    uniform float yNew;
    uniform float xLim;
    uniform float yLim;

    varying vec2 vTextureCoord;

    void main(void) {
        vec2 newVertexPosition = aVertexPosition;
        vec2 newTextureCoord   = aTextureCoord;
        if((xOld != xNew) || (yOld != yNew)) {
            if(abs(xOld - xNew) > abs(yOld - yNew)) {   //horizontal stretch
                if((aVertexPosition.x > -1.0) && (aVertexPosition.x < 1.0)) {
                     newVertexPosition = vec2(-1.0 + (2.0*xNew/xLim), aVertexPosition.y);
                }
            }
            else {  //vertical stretch
                if((aVertexPosition.y > -1.0) && (aVertexPosition.y < 1.0)) {
                    newVertexPosition = vec2(aVertexPosition.x, -1.0 + (2.0*(yLim - yNew)/yLim));
                }
            }
        }

        gl_Position = vec4(newVertexPosition, 0.0, 1.0);
        vTextureCoord = newTextureCoord;
    }
</script>

<script id="shader-vs-Mesh" type="x-shader/x-vertex"> 
    attribute vec2 aVertexPosition;
    attribute vec2 aNewVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec2 aNewTextureCoord;
    
    uniform float xOld;
    uniform float yOld;
    uniform float xNew;
    uniform float yNew;
    uniform float xLim;
    uniform float yLim;
    
    varying vec2 vTextureCoord;

    void main(void) {
        vec2 newVertexPosition = vec2(aNewVertexPosition.x, aNewVertexPosition.y);
        vec2 newTextureCoord   = vec2(aNewTextureCoord.s, aNewTextureCoord.t);
        gl_Position = vec4(newVertexPosition, 0.0, 1.0);
        vTextureCoord   = aTextureCoord;
    }
</script>

<script id="shader-fs" type="x-shader/x-fragment">
    precision mediump float;
    
    varying vec2 vTextureCoord;

    uniform sampler2D uSampler;

    uniform float xOld;
    uniform float yOld;
    uniform float xNew;
    uniform float yNew;
    uniform float xLim;
    uniform float yLim;

    float dist(float x1, float y1, float x2, float y2) {
        return sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    }

    void main(void) {
        vec2 pt1 = gl_FragCoord.xy;
        
        vec2 newTextureCoord = vec2(vTextureCoord.s, vTextureCoord.t);
        vec4 textColor = texture2D(uSampler, newTextureCoord);

        float alpha = 1.0;
        if((xOld != xNew) || (yOld != yNew)) {
            float pointerRadius = 10.0;
            float d = dist(pt1.x, pt1.y, xNew, yLim - yNew);
            if((d < (pointerRadius + 1.4)) && (d > (pointerRadius - 1.4))) { 
                alpha = 0.5;    //highlight pointer
                //textColor.r = 1.0;
                //textColor.g = 0.0;
                textColor.b += 0.1;
            }
        }

        gl_FragColor = textColor * alpha;
    }
</script>



<script id="warpgl" type="text/javascript">
<!-- src="./warpgrid.js"-->
var paintConfigs = new Object();
paintConfigs["paint8_2D"]  = ["shader-vs-2D", "shader-fs", paint8];
paintConfigs["paint8_1D"]  = ["shader-vs-1D", "shader-fs", paint8];

var gl = null;
var prog = null;
var width = 0.0;
var height = 0.0;
var aspectRatio = 1.0;
var paintConfig = paintConfigs["paint8_2D"];

function replaceCanvas(renewCtx) {
    var canvasParentElement = document.getElementById("bg");
    canvasElement = document.getElementById("kanvas");
    canvasParentElement.removeChild(canvasElement);
    canvasParentElement.innerHTML = '<canvas id="kanvas" style="position:absolute; left:0px; top:0px;" width="500" height="520">Your browser does not support the canvas tag</canvas>';
    canvasElement = document.getElementById("kanvas");
    activeHeight = canvasElement.height;
    activeWidth  = canvasElement.width;
    if(renewCtx) {
        gl = null;
        ctx = canvasElement.getContext("2d");
    }
    initCanvas();
}

//some boilerplate code copied and adapted from http://www.klokantech.com/
function initGL() {
    try {
        //remove old canvas first
        if(ctx != null) {
            ctx = null;
            replaceCanvas();
        }
        var gl = canvasElement.getContext("webgl") || canvasElement.getContext("experimental-webgl");
    } catch (err) {
        console.log(err);
        debug(err);
    }
    return gl;
}

function shaderProgram(gl, vs, fs) {
    var prog = gl.createProgram();
    var addshader = function(type, source) {
        var s = gl.createShader((type == 'vertex') ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);
        gl.shaderSource(s, source);
        gl.compileShader(s);
        if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
            throw "Could not compile "+type+" shader:\n\n"+gl.getShaderInfoLog(s);
        }
        gl.attachShader(prog, s);
    };
    addshader('vertex', document.getElementById(vs).textContent);
    addshader('fragment', document.getElementById(fs).textContent);
    gl.linkProgram(prog);
    if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
        throw "Could not link the shader program!";
    }
    return prog;
}

function attributeSetFloats(gl, prog, attr_name, rsize, arr) {
    gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(arr), gl.STATIC_DRAW);
    var attr = gl.getAttribLocation(prog, attr_name);
    gl.enableVertexAttribArray(attr);
    gl.vertexAttribPointer(attr, rsize, gl.FLOAT, false, 0, 0);
}


function initGLDraw(imgData, imgW, imgH) {
    if (!gl) {
        gl = initGL();
        if (!gl) { throw "Your web browser does not support WebGL!"; }
    }
    canvasElement = document.getElementById("kanvas");
    
    gl.clearColor(1, 1, 1, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);
  
    prog = shaderProgram(gl, paintConfig[0], paintConfig[1]);
    gl.useProgram(prog);

    prog.xNew = gl.getUniformLocation(prog, "xNew");
    prog.yNew = gl.getUniformLocation(prog, "yNew");
    prog.xOld = gl.getUniformLocation(prog, "xOld");
    prog.yOld = gl.getUniformLocation(prog, "yOld");
    prog.xLim = gl.getUniformLocation(prog, "xLim");
    prog.yLim = gl.getUniformLocation(prog, "yLim");

    prog.xNewNorm = gl.getUniformLocation(prog, "xNewNorm");
    prog.yNewNorm = gl.getUniformLocation(prog, "yNewNorm");
    prog.xOldNorm = gl.getUniformLocation(prog, "xOldNorm");
    prog.yOldNorm = gl.getUniformLocation(prog, "yOldNorm");
    
    prog.stretchVecM     = gl.getUniformLocation(prog, "stretchVecM");
    prog.stretchVecC     = gl.getUniformLocation(prog, "stretchVecC");
    prog.stretchVecAnchX = gl.getUniformLocation(prog, "stretchVecAnchX");
    prog.stretchVecAnchY = gl.getUniformLocation(prog, "stretchVecAnchY");
    prog.stretchRatio    = gl.getUniformLocation(prog, "stretchRatio");

    var loadTexture = function(texture, typedPixelArray, wd, ht) {
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

        if(typedPixelArray && wd && ht) {
            //gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, typedPixelArray);
            console.log("dim="+wd+","+ht+" pix="+typedPixelArray+"=["+typedPixelArray[0]+","+typedPixelArray[1]+","+typedPixelArray[2]+"...");
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, wd, ht, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(typedPixelArray));
            width  = wd;
            height = ht;
            canvasElement = document.getElementById("kanvas");
            canvasElement.height = ht;
            canvasElement.width = wd;
            gl.viewport(0, 0, width, height);
            //gl.viewport(0, 0, activeWidth, activeHeight);
        }
        else {
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA,
                gl.UNSIGNED_BYTE, texture.image);
            var w = width  = texture.image.width * 1.0;
            var h = height = texture.image.height * 1.0;
            
            canvasElement = document.getElementById("kanvas");
            canvasElement.height = ht;
            canvasElement.width = wd;
            
            texture.image.height = height = activeHeight = canvasElement.height = canvasElement.width * h/w;
            texture.image.width  = width = canvasElement.width;
            gl.viewport(0, 0, canvasElement.width, canvasElement.height);
        }
        
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        
        stretchContentGL(0, 0);
    };
    
    var texture = gl.createTexture();
    if(imgData && imgW && imgH) {
        loadTexture(texture, imgData, imgW, imgH);
    }
    else {
        texture.image = new Image();
        texture.image.onload = function() {
            loadTexture(texture);
        }
        texture.image.src = imgURL;
    }
}

function stretchContentGL(x, y) {
    return paintConfig[2](x, y);
}

function buildTriangles4(minX, minY, maxX, maxY, midX, midY, indices) {
    var arr = [
            maxX, maxY,
            midX, midY,
            minX, maxY,
            midX, midY,
            minX, minY,
            midX, midY,
            maxX, minY,
            midX, midY,
            maxX, maxY,
        ];
    indices.push.apply(indices, [0, 2, 4, 6]);
    return arr;
}

function buildTriangles8(minX, minY, maxX, maxY, midX, midY, indexes) {
    var arr = [
            maxX, maxY,           //1st
            midX, maxY,         //2nd
            midX, midY,       //3rd
            minX, maxY,
            minX, midY,        //4th
            midX, midY,       //5th
            minX, minY,
            midX, minY,        //6th
            midX, midY,       //7th
            maxX, minY,
            maxX, midY,         //8th
            midX, midY,
            maxX, maxY
        ];
    indexes.push.apply(indexes, [0, 1, 2, 4, 5, 7, 8, 10]);
    return arr;
}

function paint4(x, y) {
    gl.uniform1f(prog.xLim, activeWidth);
    gl.uniform1f(prog.yLim, activeHeight);
    gl.uniform1f(prog.xOld, startX);
    gl.uniform1f(prog.yOld, startY);
    gl.uniform1f(prog.xNew, x);
    gl.uniform1f(prog.yNew, y);
    
    var nvertices = 9;
    var vertArr = null;
    var textArr = null;
    var indices = [];
    if((x == 0) && (y == 0)) {
        // the model (nodes in 2d space)
        vertArr = buildTriangles4(-1, -1, 1, 1, 0, 0, indices);
        textArr = buildTriangles4(0, 0, 1, 1, 0.5, 0.5, indices);
    }
    else {
        var vmx = -1.0 + (2 * startX/width);
        var vmy = -1.0 + (2 * (height - startY)/height);
        var tmx = (startX/width);
        var tmy = ((height - startY)/height);        

        vertArr = buildTriangles4(-1, -1, 1, 1, vmx, vmy, indices);
        textArr = buildTriangles4(0, 0, 1, 1, tmx, tmy, indices);
    }
    attributeSetFloats(gl, prog, "aVertexPosition", 2, vertArr);
    attributeSetFloats(gl, prog, "aTextureCoord", 2, textArr);
    nvertices = indices.length;
    for(var i = 0; i < nvertices; i++) {
        gl.drawArrays(gl.TRIANGLE_STRIP, indices[i], 3);
    }
    
    //gl.drawArrays(gl.TRIANGLE_FAN, 0, np);
    //gl.drawArrays(gl.LINE_STRIP, 0, np);
}

function paint8() {
    gl.uniform1f(prog.xLim, width);
    gl.uniform1f(prog.yLim, height);
    gl.uniform1f(prog.xOld, startX);
    gl.uniform1f(prog.yOld, startY);    //(startX && startY ? height - startY : 0));
    gl.uniform1f(prog.xNew, mouseX);    //(startX - stretchX));
    gl.uniform1f(prog.yNew, mouseY); //(mouseX && mouseY ? height - mouseY : 0));   //(startY + stretchY));
    
    var nvertices = 13;
    var vertArr = null;
    var textArr = null;
    var indexes = [];
    if((startX == 0) && (startY == 0)) {
        // the model (nodes in 2d space)
        vertArr = buildTriangles8(-1, -1, 1, 1, 0, 0, indexes);
        textArr = buildTriangles8(0, 0, 1, 1, 0.5, 0.5, indexes);
    }
    else {
        var vmx = -1.0 + (2*startX/width);
        var vmy = -1.0 + (2*(height - startY)/height);
        var tmx = (startX/width);
        var tmy = ((height - startY)/height);        

        vertArr = buildTriangles8(-1, -1, 1, 1, vmx, vmy, indexes);
        textArr = buildTriangles8(0, 0, 1, 1, tmx, tmy, indexes);
    }
    attributeSetFloats(gl, prog, "aVertexPosition", 2, vertArr);
    attributeSetFloats(gl, prog, "aTextureCoord", 2, textArr);

    for(var i = 0; i < nvertices; i++) {
        gl.drawArrays(gl.TRIANGLE_STRIP, indexes[i], 3);
    }

    //gl.drawArrays(gl.TRIANGLES, 0, np);
    //gl.drawArrays(gl.TRIANGLE_FAN, 0, np);
    //gl.drawArrays(gl.LINE_STRIP, 0, np);
}
</script>

<script id="warpgrid" type="text/javascript">

//image warping stuff
/*
    Adopted from Java code by Jerry Huxtable at http://www.jhlabs.com/ip/index.html
*/
var m00 = -0.5;
var m01 =  1.5;
var m02 = -1.5;
var m03 =  0.5;
var m10 =  1.0;
var m11 = -2.5;
var m12 =  2.0;
var m13 = -0.5;
var m20 = -0.5;
var m22 =  0.5;
var m31 =  1.0;
	
function setval(arr, val) {
	for(var i = 0, n = arr.length; i < n; i++) { arr[i] = val; }
}

//use float32/int32 arrays if browser has them
var FloatArray = Array;
if(typeof Float32Array == 'function') { 
    FloatArray = Float32Array;
}
var IntArray = Array;
if(typeof Int32Array == 'function') { 
    IntArray = Int32Array;
}

function newFloatArray(size, defval) {
   var arr = new FloatArray(size);//Array(size);
   if(defval) {
       setval(arr, defval);
   }
   return arr;
}

function newIntArray(size, defval) {
   var arr = new Int32Array(size);//Array(size);
   if(defval) {
       setval(arr, defval);
   }
   return arr;
}	
    
function packToIntArray(unpacked, packed) {
    if(!packed) {
        packed = newIntArray(unpacked.length / 4);
    }
    for(var i = 0, n = packed.length; i < n; i++) {
        var j = i * 4;
        packed[i] = (unpacked[j + 3] << 24) |
					(unpacked[j] << 16) |   
					(unpacked[j + 1] << 8) |
					(unpacked[j + 2]);
    } 
    //debug("Packed ["+unpacked[0]+","+unpacked[1]+","+unpacked[2]+","+unpacked[2]+"] to "+packed[0]); 
    return packed;
}

function unpackFromIntArray(packed, unpacked) {
    if(!unpacked) {
        unpacked = newIntArray(packed.length * 4);
    }
    var index = 0;
    for(var i = 0, n = packed.length; i < n; i++) {
        var rgb = packed[i];
		unpacked[index++] = (rgb >> 16) & 0xff;
		unpacked[index++] = (rgb >> 8) & 0xff;
		unpacked[index++] = (rgb & 0xff);
		unpacked[index++] = (rgb >> 24) & 0xff;
    }
    //debug("Unpacked: " + packed[0]+" to  ["+unpacked[0]+","+unpacked[1]+","+unpacked[2]+","+unpacked[2]+"]"); 
    return unpacked;
}

//TODO: Figure out how to port this *properly* to WebGL
function resample(source, dest, length, offset, stride, out) {
	//public static void resample(int[] source, int[] dest, int length, int offset, int stride, float[] out)
	var i = 0, j = 0;
	var sizfac = 0.0;
	var inSegment = 0.0;
	var outSegment = 0.0;
	var a = 0, r = 0, g = 0, b = 0, nextA = 0, nextR = 0, nextG = 0, nextB = 0;
	var aSum = 0.0, rSum = 0.0, gSum = 0.0, bSum = 0.0;
	//float[] in;
	var srcIndex = offset;
	var destIndex = offset;
	var lastIndex = source.length;
	var rgb = 0;

	var inp = newFloatArray(length+2);
	i = 0;
	for (j = 0; j < length; j++) {
		while (out[i+1] < j)
			i++;
		inp[j] = i + 1.0 * (j - out[i]) / (out[i + 1] - out[i]);
        //inp[j] = clamp( inp[j], 0, length-1 );
	}
	inp[length] = length;
	inp[length+1] = length;

	inSegment  = 1.0;
	outSegment = inp[1];
	sizfac = outSegment;
	aSum = rSum = gSum = bSum = 0.0;
	rgb = source[srcIndex];
	a = (rgb >> 24) & 0xff;
	r = (rgb >> 16) & 0xff;
	g = (rgb >> 8) & 0xff;
	b = rgb & 0xff;
	srcIndex += stride;
	rgb = source[srcIndex];
	nextA = (rgb >> 24) & 0xff;
	nextR = (rgb >> 16) & 0xff;
	nextG = (rgb >> 8) & 0xff;
	nextB = rgb & 0xff;
	srcIndex += stride;
	i = 1;

	while (i <= length) {
		var aIntensity = inSegment * a + (1.0 - inSegment) * nextA;
		var rIntensity = inSegment * r + (1.0 - inSegment) * nextR;
		var gIntensity = inSegment * g + (1.0 - inSegment) * nextG;
		var bIntensity = inSegment * b + (1.0 - inSegment) * nextB;
		if (inSegment < outSegment) {
			aSum += (aIntensity * inSegment);
			rSum += (rIntensity * inSegment);
			gSum += (gIntensity * inSegment);
			bSum += (bIntensity * inSegment);
			outSegment -= inSegment;
			inSegment = 1.0;
			a = nextA;
			r = nextR;
			g = nextG;
			b = nextB;
			if (srcIndex < lastIndex)
				rgb = source[srcIndex];
			nextA = (rgb >> 24) & 0xff;
			nextR = (rgb >> 16) & 0xff;
			nextG = (rgb >> 8) & 0xff;
			nextB = rgb & 0xff;
			srcIndex += stride;
		} else {
			aSum += (aIntensity * outSegment);
			rSum += (rIntensity * outSegment);
			gSum += (gIntensity * outSegment);
			bSum += (bIntensity * outSegment);
			dest[destIndex] = 
				(Math.round(Math.min(aSum/sizfac, 255) << 24)) |
				(Math.round(Math.min(rSum/sizfac, 255) << 16)) |
				(Math.round(Math.min(gSum/sizfac, 255) << 8)) |
				Math.round(Math.min(bSum/sizfac, 255));
			destIndex += stride;
			aSum = rSum = gSum = bSum = 0.0;
			inSegment -= outSegment;
			outSegment = inp[i+1] - inp[i];
			sizfac = outSegment;
			i++;
		}
	}
}

function WarpGrid(rows, cols, w, h) {        	        
   //public WarpGrid(int rows, int cols, int w, int h) {
	this.rows = rows;
	this.cols = cols;
	this.xGrid = newFloatArray(rows*cols);
	this.yGrid = newFloatArray(rows*cols);
	var index = 0;
	for (var row = 0; row < rows; row++) {
		for (var col = 0; col < cols; col++) {
			this.xGrid[index] = 1.0 * (col*(w-1)/(cols-1));
			this.yGrid[index] = 1.0 * (row*(h-1)/(rows-1));
			index++;
		}
	}
}

WarpGrid.prototype.warp = function(inPixels, cols, rows, sourceGrid, destGrid, outPixels) {
   //(int[] inPixels, int cols, int rows, WarpGrid sourceGrid, WarpGrid destGrid, int[] outPixels) {
    /*try { */
		var x = 0, y = 0; //int
		var u = 0, v = 0; //int
		//var intermediate = new Array();
		//WarpGrid splines;

		if (sourceGrid.rows != destGrid.rows || sourceGrid.cols != destGrid.cols)
			throw ("source and destination grids are different sizes");

		var size = Math.max(cols, rows);
		var xrow = newFloatArray(size);
		var yrow = newFloatArray(size);
		var scale  = newFloatArray(size + 1);
		var interpolated = newFloatArray(size + 1);
		//init to 0
		setval(interpolated, 0);

		var gridCols = sourceGrid.cols;
		var gridRows = sourceGrid.rows;

		splines = new WarpGrid(rows, gridCols, 1, 1);

		for (u = 0; u < gridCols;u++) {
			var i = u;

			for (v = 0; v < gridRows;v++) {
				xrow[v] = sourceGrid.xGrid[i];
				yrow[v] = sourceGrid.yGrid[i];
				i += gridCols;
			}

			this.interpolateSpline(yrow, xrow, 0, gridRows, interpolated, 0, rows);

			i = u;
			for (y = 0;y < rows;y++) {
				splines.xGrid[i] = interpolated[y];
				i += gridCols;
			}
		}

		for (u = 0; u < gridCols;u++) {
			var i = u;

			for (v = 0; v < gridRows;v++) {
				xrow[v] = destGrid.xGrid[i];
				yrow[v] = destGrid.yGrid[i];
				i += gridCols;
			}

			this.interpolateSpline(yrow, xrow, 0, gridRows, interpolated, 0, rows);

			i = u;
			for (y = 0;y < rows; y++) {
				splines.yGrid[i] = interpolated[y];
				i += gridCols;
			}
		}

		/* first pass: warp x using splines */
		intermediate = newIntArray(rows*cols);  //int

		var offset = 0;
	    timeIt("warp: pre-resample 1 = "+rows);
	    var interpT = 0;
	    var resampleT = 0;
		for (y = 0; y < rows; y++) {
			/* fit spline to x-intercepts;resample over all cols */
			var t1 = new Date().getTime();
			this.interpolateSpline(splines.xGrid, splines.yGrid, offset, gridCols, scale, 0, cols);
			var t2 = new Date().getTime();
			scale[cols] = cols;
			resample(inPixels, intermediate, cols, y*cols, 1, scale);
			var t3 = new Date().getTime();
			interpT += (t2 - t1);
			resampleT += (t3 - t2);
			offset += gridCols;
		}
	    timeIt("warp: resample #"+rows+" (i="+interpT+" + r="+resampleT+") 1");

		/* create table of y-intercepts for intermediate mesh's hor splines */

		splines = new WarpGrid(gridRows, cols, 1, 1);

		offset = 0;
		var offset2 = 0;
		for (v = 0; v < gridRows; v++) {
			this.interpolateSpline(sourceGrid.xGrid, sourceGrid.yGrid, offset, gridCols, splines.xGrid, offset2, cols);
			offset += gridCols;
			offset2 += cols;
		}

		offset = 0;
		offset2 = 0;
		for (v = 0; v < gridRows; v++) {
			this.interpolateSpline(destGrid.xGrid, destGrid.yGrid, offset, gridCols, splines.yGrid, offset2, cols);
			offset += gridCols;
			offset2 += cols;
		}
        	        
		/* second pass: warp y */
	    interpT = 0;
	    resampleT = 0;
		for (x = 0; x < cols; x++) {
			var i = x;
			
			for (v = 0; v < gridRows; v++) {
				xrow[v] = splines.xGrid[i];
				yrow[v] = splines.yGrid[i];
				i += cols;
			}
			var t1 = new Date().getTime();

			this.interpolateSpline(xrow, yrow, 0, gridRows, scale, 0, rows);
			var t2 = new Date().getTime();
			scale[rows] = rows;
			resample(intermediate, outPixels, rows, x, cols, scale);
			var t3 = new Date().getTime();
			interpT += (t2 - t1);
			resampleT += (t3 - t2);
		}
		timeIt("warp: 2ndpass resample #"+rows+" (i="+interpT+" + r="+resampleT+") 1");
    /*}
    catch (e) {
    	debug(e);
    }*/
}

WarpGrid.prototype.interpolateSpline = function(xKnots, yKnots, offset, length, splineY, splineOffset, splineLength) {
//protected void interpolateSpline(float[] xKnots, float[] yKnots, int offset, int length, float[] splineY, int splineOffset, int splineLength) {
	var index = offset;
	var end = offset+length-1;
	var x0 = 0.0, x1 = 0.0;
	var k0 = 0.0, k1 = 0.0, k2 = 0.0, k3 = 0.0;
	var c0 = 0.0, c1 = 0.0, c2 = 0.0, c3 = 0.0;

	x0 = xKnots[index];
	k0 = k1 = k2 = yKnots[index];
	x1 = xKnots[index+1];
	k3 = yKnots[index+1];

	for (var i = 0;i < splineLength;i++) {
		if (index <= end && i > xKnots[index]) {
			k0 = k1;
			k1 = k2;
			k2 = k3;
			x0 = xKnots[index];
			index++;
			if ( index <= end )
				x1 = xKnots[index];
			if ( index < end )
				k3 = yKnots[index+1];
			else
				k3 = k2;
		}
		t = 1.0 * ((i - x0) / (x1 - x0));
		c3 = m00*k0 + m01*k1 + m02*k2 + m03*k3;
		c2 = m10*k0 + m11*k1 + m12*k2 + m13*k3;
		c1 = m20*k0 + m22*k2;
		c0 = m31*k1;
		
		splineY[splineOffset+i] = ((c3*t + c2)*t + c1)*t + c0;
	}
}
</script>
<script id="pagescript" type="text/javascript">
    var canvasElement;
    var ctx;
    var debugCell;
    var contentElement;
    
    var modes = ["stretch2D", "stretch1D", "stretchGL2D", "stretchGL1D"];
    var currentMode = "stretch2D"; 
    
    var activeWidth;
    var activeHeight;
    var winWidth;
    var winHeight;
    var absX = 0;
    var absY = 0;
    var winX = 0;
    var winY = 0;
    Element.prototype.leftTopScreen = function () {
        var x = parseInt(this.offsetLeft);
        var y = parseInt(this.offsetTop);
    
        var element = this.offsetParent;
    
        while (element !== null) {
            x += parseInt (element.offsetLeft);
            y += parseInt (element.offsetTop);
    
            element = element.offsetParent;
        }
    
        return new Point(x, y);
    }
    
    var imgContent = null;
    var drawContent = drawContentText;  //drawContentImage;
    function changeDisplay(disp) {
        imgContent = null;
        if(disp === 'text') {
            drawContent = drawContentText;
        }
        else if(disp === 'image') {
            drawContent = drawContentImage;
        }
        else {
            drawContent = drawContentMixed;
        }
        drawContent(0, 0);
    }
    
    function disableDisplayOptions(b) {
        document.getElementById("imgDisplay").disabled = b;
        document.getElementById("txtDisplay").disabled = b;
        document.getElementById("mixDisplay").disabled = b;
        if(!b) {
            document.getElementById("imgDisplay").checked  = true;
        }
    }
    
    var showedWarning = false;
    function changeMode(m) {
        currentMode = m;

        contentElement.scrollTop = 0;
        contentElement.scrollLeft = 0;
        updateTable();
        var warnDiv = document.getElementById("warning");
        //if(!showedWarning && (m =="stretch2D")) {
        //  showedWarning = true;
        disableDisplayOptions(false);
        document.getElementById("stretch1DChk").checked = false;
        document.getElementById("stretch2DChk").checked = false;
        document.getElementById("stretchGL1DChk").checked = false;
        document.getElementById("stretchGL2DChk").checked = false;
        if(m =="stretch2D") {
            if(gl != null) {
                replaceCanvas(true);
            }
            drawContent(0, 0);
            document.getElementById("stretch2DChk").checked = true;
            warnDiv.innerHTML = ("<font color='RED'>Note that 2D warping is a processor intensive function that can take upto "
                +"a second (or 5, on an iPad) to compute and render every mouse drag in JavaScript. "
                +"It would be much faster if implemented using WebGL (work in progress). "
                +"Please drag your mouse slowly to get more effective results.</font>");
        }
        else if(m =="stretch1D") {
            if(gl != null) {
                replaceCanvas(true);
            }
            drawContent(0, 0);
            document.getElementById("stretch1DChk").checked = true;
            warnDiv.innerHTML = "";
        }
        else if(m =="stretchGL1D") {
            //disableDisplayOptions(true);
            document.getElementById("stretchGL1DChk").checked = true;

            paintConfig = paintConfigs["paint8_1D"];

            initGLDraw(imgContent.data, imgContent.width, imgContent.height);
            warnDiv.innerHTML = "";
        }
        else if(m =="stretchGL2D") {
            //disableDisplayOptions(true);
            document.getElementById("stretchGL2DChk").checked = true;
            paintConfig = paintConfigs["paint8_2D"];

            initGLDraw(imgContent.data, imgContent.width, imgContent.height);
            warnDiv.innerHTML = "";
        }
    }

    function initCanvas() {
        var absPt = canvasElement.leftTopScreen();
        absX = absPt.x;
        absY = absPt.y;
    
        var winPt = canvasElement.leftTopScreen();
        winX = winPt.x;
        winY = winPt.y;

        activeWidth  = winWidth  = parseInt(canvasElement.width);
        activeHeight = winHeight = parseInt(canvasElement.height);

        canvasElement.addEventListener("mousedown", onMouseDown, false);
        canvasElement.addEventListener("mouseup", onMouseUp, false);
    
        canvasElement.addEventListener("touchstart", onMouseDown, false);
        canvasElement.addEventListener("touchend", onMouseUp, false);
    }
    
    function init() {
        debugCell = document.getElementById("debugCell");
    
        contentElement = document.getElementById("kanvas");
        activeWidth  = winWidth  = parseInt(contentElement.style.width.split("px")[0]);
        activeHeight = winHeight = parseInt(contentElement.style.height.split("px")[0]);
    
        contentElement.onmouseover=function(){
            document.getElementsByTagName('body')[0].style.overflow='hidden';
        }
        contentElement.onmouseout=function(){
            document.getElementsByTagName('body')[0].style.overflow='';
        }            
    
        canvasElement = document.getElementById("kanvas");
        ctx = canvasElement.getContext("2d");
        
        initCanvas();

        changeDisplay("image");
        changeMode("stretch2D");
    
        drawContent(0, 0);
        
        var rows = 7;
        var cols = 7;
        var srcGrid = new WarpGrid(rows, cols, canvasElement.width, canvasElement.height);
        var dstGrid = new WarpGrid(rows, cols, canvasElement.width, canvasElement.height);
        //paintGrid(srcGrid, "#0000FF", 0);
        generateNxMMesh(rows, cols, 100, 100, 120, 120, winWidth, winHeight, canvasElement.width, canvasElement.height, srcGrid, dstGrid);
        //paintGrid(srcGrid, "#FF0000", 0);
        //paintGrid(dstGrid, "#00FF00", 0);
    }
    
    function drawBackground() {
        if(!ctx) {
            replaceCanvas(true);
            ctx.fillStyle = "rgb(100,100,100)";
            ctx.fillRect(0, 0, canvasElement.width, canvasElement.height);
        }
        else {
            ctx.fillStyle = "rgb(100,100,100)";
            ctx.fillRect(0, 0, canvasElement.width, canvasElement.height);
        }
    }
    
    function getLines(c,phrase,maxPxLength,textStyle) {
        var wa=phrase.split(" "),
            phraseArray=[],
            lastPhrase="",
            l=maxPxLength,
            measure=0;
        c.font = textStyle;
        for (var i=0;i<wa.length;i++) {
            var w=wa[i];
            measure=c.measureText(lastPhrase+w).width;
            if (measure<l) {
                lastPhrase+=(" "+w);
            }else {
                phraseArray.push(lastPhrase);
                lastPhrase=w;
            }
            if (i===wa.length-1) {
                phraseArray.push(lastPhrase);
                break;
            }
        }
        return phraseArray;
    }
    
    var touchPointStyle = "rgb(255,255,255)";
    var isLightBG = false;
    var imgURL = "./African_landscape.jpeg";
    //var imgURL = "./me-at-work.jpeg";
    
    var txtContent = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Etiam faucibus viverra ligula a facilisis. Nunc facilisis faucibus urna sed ultrices. Nunc vitae arcu ante. Curabitur semper bibendum ante sed consectetur. Etiam accumsan felis quis risus interdum sed fringilla orci accumsan. In placerat eros eu turpis rhoncus vehicula. In venenatis malesuada velit, eu rutrum libero congue id. Proin in enim sem, at malesuada purus. Nullam convallis sagittis quam nec pulvinar.\n\nDonec vitae nisl ac urna condimentum malesuada pharetra vel sapien. Donec auctor mattis nisl vitae feugiat. Nulla malesuada, nunc condimentum porta porttitor, nulla arcu tincidunt quam, a ullamcorper dolor velit auctor lectus. Quisque rutrum facilisis enim, vel commodo metus pulvinar ac. Pellentesque sed elit sem, at mattis dui. Duis vel felis ac sem rutrum ornare sed in augue. Fusce euismod tempus massa eu auctor. Phasellus leo nibh, consectetur eget fringilla ut, posuere in felis. Duis scelerisque facilisis nisl eu tempus. Pellentesque ultricies eleifend ullamcorper.\n\nDonec vitae nisl ac urna condimentum malesuada pharetra vel sapien. Donec auctor mattis nisl vitae feugiat. Nulla malesuada, nunc condimentum porta porttitor, nulla arcu tincidunt quam, a ullamcorper dolor velit auctor lectus. Quisque rutrum facilisis enim, vel commodo metus pulvinar ac. Pellentesque sed elit sem, at mattis dui. Duis vel felis ac sem rutrum ornare sed in augue. Fusce euismod tempus massa eu auctor. Phasellus leo nibh, consectetur eget fringilla ut, posuere in felis. Duis scelerisque facilisis nisl eu tempus. Pellentesque ultricies eleifend ullamcorper.";
    
    function drawContentText(x, y) {
        if(imgContent == null) {
            drawBackground();
            var maxWidth = 400;
            var bgr = 255;
            var bgg = 255;
            var bgb = 255;
            ctx.fillStyle = "rgb("+bgr+","+bgg+","+bgb+")";
            touchPointStyle = "rgb("+(350 - bgr)+","+(350 - bgg)+","+(350 - bgb)+")";
            if(((bgr + bgg + bgb) / 3) > 200) {
                isLightBG = true;
            }
            ctx.fillRect(x, y, canvasElement.width, canvasElement.height);
            ctx.fillStyle = "Black";
            ctx.font = "30pt Arial";
            ctx.fillText("Lorem Ipsum", x + 120, y + 50);
            ctx.font = "11pt Arial";
    
            var txtArray = getLines(ctx, txtContent, maxWidth, ctx.font);
            //var ht = ctx.measureText(txtArray[0]).height;
            var ht = 13;
            //debug("n array="+txtArray.length+" ht="+ht);
            var brY = 0;
            for(var j = 0, n = txtArray.length; j < n; j++) {
                ctx.fillText(txtArray[j], x+50, y + 100 + (j*ht + 5) + brY);
                if((j + 1) % 10 == 0) {
                    brY += 10;
                }
            }
            imgContent = ctx.getImageData(0, 0, canvasElement.width, canvasElement.height); 
            activeWidth  = canvasElement.width;   
            activeHeight = canvasElement.height;
        }
        else {
            drawBackground();
            ctx.putImageData(imgContent, x, y);
        }
    }
    
    function drawContentImage(x, y) {
        if(imgContent == null) {
            drawBackground();
            var maxWidth = 400;
            var bgr = 255;
            var bgg = 255;
            var bgb = 255;
            ctx.fillStyle = "rgb("+bgr+","+bgg+","+bgb+")";
            touchPointStyle = "rgb("+(350 - bgr)+","+(350 - bgg)+","+(350 - bgb)+")";
            if(((bgr + bgg + bgb) / 3) > 200) {
                isLightBG = true;
            }
            ctx.fillRect(x, y, canvasElement.width, canvasElement.height);
    
            var img = new Image();  
            img.onload = function(){  
                var wdraw = (canvasElement.width);
                var hdraw = img.height * (wdraw/img.width);
                ctx.drawImage(img, x, y, wdraw, hdraw);  
                
                activeWidth  = wdraw;   
                activeHeight = hdraw;
                imgContent = ctx.getImageData(0, 0, activeWidth, activeHeight); 
            };  
            img.src = imgURL;
        }
        else {
            drawBackground();
            ctx.putImageData(imgContent, x, y);
        }
    }
    
    function drawContentMixed(x, y) {
        if(imgContent == null) {
            drawBackground();
            var maxWidth = 400;
            var bgr = 255;
            var bgg = 255;
            var bgb = 255;
            ctx.fillStyle = "rgb("+bgr+","+bgg+","+bgb+")";
            touchPointStyle = "rgb("+(350 - bgr)+","+(350 - bgg)+","+(350 - bgb)+")";
            if(((bgr + bgg + bgb) / 3) > 200) {
                isLightBG = true;
            }
            ctx.fillRect(x, y, canvasElement.width, canvasElement.height);
            ctx.fillStyle = "Black";
            ctx.font = "30pt Arial";
            ctx.fillText("Lorem Ipsum", x + 120, y + 50);
    
            var img = new Image();  
            img.onload = function() {
                var wdraw = 210;
                var hdraw = img.height * (wdraw/img.width);
                var yOff = hdraw;
                var imgMidX = x + (canvasElement.width - wdraw) / 2;
                ctx.drawImage(img, imgMidX, y + 60, wdraw, hdraw);
                
                ctx.font = "10pt Arial";
                var txtArray = getLines(ctx, txtContent, maxWidth, ctx.font);
                //var ht = ctx.measureText(txtArray[0]).height;
                var ht = 12;
                //debug("n array="+txtArray.length+" ht="+ht);
                var brY = 0;
                for(var j = 0, n = txtArray.length; j < n; j++) {
                    ctx.fillText(txtArray[j], x+50, y + yOff + 100 + (j*ht + 5) + brY);
                    if((j + 1) % 10 == 0) {
                        brY += 10;
                    }
                }
                activeWidth  = canvasElement.width;   
                activeHeight = canvasElement.height;
                imgContent = ctx.getImageData(0, 0, canvasElement.width, canvasElement.height); 
            };  
            img.src = imgURL;
        }
        else {
            drawBackground();
            ctx.putImageData(imgContent, x, y);
        }
    }
    
    var startX = 0;            // mouse starting positions
    var startY = 0;
    var startScrollLeft = 0;   // scroll starting positions
    var startScrollTop = 0;
    var offsetX = 0;           // current element offset
    var offsetY = 0;
    var mouseX = 0;           // current mouse coordinates
    var mouseY = 0;
    
    var mouseDown = false;
    var elasticDeltaT = 10;
    var elasticDeltaX = 0;
    var elasticDeltaY = 0;
    var elasticDistX = 0;
    var elasticDistY = 0;
    
    function debug(str) {
        if(document.getElementById("showdebug").checked) {
            debugCell.innerHTML = str +"<br/>" + debugCell.innerHTML;
        }
    }
    
    function showDebug() {
        if(document.getElementById("showdebug").checked) {
            document.getElementById("debug").style.visibility = "visible";
        }
        else {
            document.getElementById("debug").style.visibility = "hidden";
        }
        return true;
    }
    
    function Point(x, y) {
        this.x = x;
        this.y = y
    }
    
    function updateTable() {
        document.getElementById("offsetX").innerHTML = offsetX;
        document.getElementById("offsetY").innerHTML = offsetY;
        document.getElementById("startX").innerHTML = startX;
        document.getElementById("startY").innerHTML = startY;
        document.getElementById("scrollTop").innerHTML = contentElement.scrollTop;
        document.getElementById("scrollLeft").innerHTML = contentElement.scrollLeft;
        document.getElementById("mouseX").innerHTML = mouseX;
        document.getElementById("mouseY").innerHTML = mouseY;
        document.getElementById("currentMode").innerHTML = currentMode;
        document.getElementById("stretchStartX").innerHTML = stretchStartX;
        document.getElementById("stretchStartY").innerHTML = stretchStartY;
        document.getElementById("stretchPointX").innerHTML = stretchPointX;
        document.getElementById("stretchPointY").innerHTML = stretchPointY;
    }
    
    function getCursorPosition(e) {
        var x;
        var y;
        if (e.pageX || e.pageY) {
            x = e.pageX;
            y = e.pageY;
        }
        else {
            x = e.clientX + document.body.scrollLeft +
                document.documentElement.scrollLeft;
            y = e.clientY + document.body.scrollTop +
                document.documentElement.scrollTop;
        }
        x -= winX;  //canvasElement.offsetLeft;
        y -= winY;  //canvasElement.offsetTop;
        return new Point(x, y);
    }
    
    var restoreRect = null;
    var restoreRectX = -1;
    var restoreRectY = -1;
    
    function showTouchPoint(x, y, restoreOnly) {
        x += contentElement.scrollLeft;
        y += contentElement.scrollTop;
        if(restoreOnly && restoreRect) { // && ((x != restoreRectX) || (y != restoreRectY))) {
            ctx.putImageData(restoreRect, restoreRectX, restoreRectY);
            restoreRect = null;
            restoreRectX = -1;
            restoreRectY = -1;
            return;
        }
    
        if(document.getElementById("showtouch").checked && (x > 0) && (y > 0)) {
            var radius = 10;
            var lw = 1;
            if(!restoreRect) {//    (x != restoreRectX) || (y != restoreRectY)) {
                restoreRectX = x - radius - lw;
                restoreRectY = y - radius - lw;
                restoreRect = ctx.getImageData(restoreRectX, restoreRectY, radius*2 + lw + 1, radius*2 + lw + 1);
            }
            ctx.strokeStyle=touchPointStyle;
            ctx.lineWidth = lw;
            ctx.beginPath();
            ctx.arc(x, y, radius, Math.PI*2, 0, true);
            ctx.closePath();
            ctx.stroke();
        }
    }
    
    function onMouseDown(e) {
        var pt = getCursorPosition(e);
        var x = startX = pt.x;
        var y = startY = pt.y;
        startScrollLeft = contentElement.scrollLeft;
        startScrollTop  = contentElement.scrollTop;
        debug("Mouse down at "+x+","+y+".");
        canvasElement.addEventListener("mousemove", onMouseMove, false);
        canvasElement.addEventListener("touchmove", onMouseMove, false);
        mouseDown = true;
        if((currentMode == "stretch1D") || (currentMode == "stretch2D")) {
            showTouchPoint(x, y);
        }
        updateTable();
    };
        
    function releaseDrag(x, y) {
        startX = startY = mouseX = mouseY = 0;
        debug("Mouse up at "+x+","+y);
        canvasElement.removeEventListener("mousemove", onMouseMove);
        canvasElement.removeEventListener("touchmove", onMouseMove);
        mouseDown = false;
        if(currentMode == "stretch2D") {
            if(stretchStartX >= 0) {
                unstretchContent2D(x, y, true);
                //showTouchPoint(-1, -1, true);
            }
            else {
                drawContent(0, 0);
            }
        }
        else if(currentMode == "stretch1D") {
            if(stretchStartX >= 0) {
                unstretchContent1D(x, y, true);
                //showTouchPoint(-1, -1, true);
            }
            else {
                drawContent(0, 0);
            }
        }
        else {
            stretchContentGL(0, 0);
        }
        updateTable();
    }
        
    function onMouseUp(e) {
        var pt = getCursorPosition(e);
        var x = pt.x;
        var y = pt.y;
        releaseDrag(x, y);
    };
    
    function onMouseMove(e) {
        var pt = getCursorPosition(e);
        var x = mouseX = pt.x;
        var y = mouseY = pt.y;
        if((x < 0) || (x >= winWidth)) {
            //x = mouseX = 0;
            releaseDrag(x, y);
            return;
        }
        if((y < 0) || (y >= winHeight)) {
            //y = mouseY = 0;
            releaseDrag(x, y);
            return;
        }
        var deltaX = x - startX;
        var deltaY = y - startY;
        offsetX = deltaX;
        offsetY = deltaY;
    
        var actualScrollTop  = startScrollTop;
        var actualScrollLeft = startScrollLeft;
        actualScrollTop  -= offsetY;
        actualScrollLeft -= offsetX;
        contentElement.scrollTop  = actualScrollTop;
        contentElement.scrollLeft = actualScrollLeft;
        
        if(currentMode == "stretch2D") {
            if(stretchStartX < 0) {
                stretchJustBegun = true;
                stretchStartX = x  + contentElement.scrollLeft;
                stretchStartY = y  + contentElement.scrollTop;
                debug("Stretch started at "+stretchStartX+","+stretchStartY+" as opposed to "+startX+","+startY);
            }
            stretchContent2D(x + contentElement.scrollLeft, y + contentElement.scrollTop);
            showTouchPoint(x, y);
        }
        else if(currentMode == "stretch1D") {
            if(stretchStartX < 0) {
                stretchJustBegun = true;
                stretchStartX = x  + contentElement.scrollLeft;
                stretchStartY = y  + contentElement.scrollTop;
                debug("Stretch started at "+stretchStartX+","+stretchStartY+" as opposed to "+startX+","+startY);
            }
            stretchContent1D(x + contentElement.scrollLeft, y + contentElement.scrollTop);
            showTouchPoint(x, y);
        }
        else {
            stretchContentGL(x, y);
        }
        updateTable();
        //debug("Mouse moved ("+deltaX+","+deltaY+") to "+x+","+y+", offset=("+offsetX+", "+offsetY+")");
    };
    
    function elasticSnapBack(isStarting) {
        if(((offsetX <= 0) && (offsetY <= 0)) || mouseDown) {
            return false;
        }
        if(isStarting) {
            elasticDistX = offsetX;
            elasticDistY = offsetY;
            elasticDeltaX = 5;
            elasticDeltaY = elasticDeltaX * (elasticDistY / elasticDistX);
            if((elasticDistX > 100) || (elasticDistY > 100)) {
                elasticDeltaT = 2;
            }
            else if(elasticDeltaY < 1) {
                elasticDeltaY = 2;
            }
            else {
                elasticDeltaT = 10;
            }
        }
        if((offsetX < 10) && (offsetY < 10)) {
            elasticDeltaT = 10;
            elasticDeltaX = 1;
            elasticDeltaY = 1;
        }
        
        offsetX -= elasticDeltaX;
        offsetY -= elasticDeltaY;
        if(offsetX < 0) {
            offsetX = 0;
        }
        if(offsetY < 0) {
            offsetY = 0;
        }
        return true;
    }
    
    function drawLine(x1, y1, x2, y2, xoff, yoff) {
        if(!xoff)
            xoff = 0;
        if(!yoff)
            yoff = 0;
        ctx.moveTo(x1 + xoff, y1 + yoff);
        ctx.lineTo(x2 + xoff, y2 + yoff);
        ctx.stroke();
    }
    
    function paintGrid(warpGrid, fstyle, xyoffset) {
        var xoffset = 0;
        var yoffset = 0;
        ctx.strokeStyle = fstyle;
        ctx.lineWidth = 1;
        ctx.beginPath();
    
        var index = 0;
        for (var row = 0; row < warpGrid.rows; row++) {
            for (var col = 0; col < warpGrid.cols; col++) {
                var x = (xoffset + warpGrid.xGrid[index]);
                var y = (yoffset + warpGrid.yGrid[index]);
                if (row > 0) 
                    drawLine(x, y, (xoffset + warpGrid.xGrid[(index - warpGrid.cols)]), (yoffset + warpGrid.yGrid[(index - warpGrid.cols)]), xyoffset, xyoffset); 
                if (col > 0)
                    drawLine(x, y, (xoffset + warpGrid.xGrid[(index - 1)]), (yoffset + warpGrid.yGrid[(index - 1)]), xyoffset, xyoffset); 
                //if ((row != 0) && (col != 0) && (row != warpGrid.rows - 1) && (col != warpGrid.cols - 1))
                //ctx.fillText("["+index+"="+row+","+col+"]", x + 5, y + 10);
                index++;
            } 
        } 
        //ctx.endPath();
    }
    
    function paintStretchMarks(srcGrid, dstGrid) {
        ctx.strokeStyle = touchPointStyle;
        ctx.lineWidth = 1;
        ctx.beginPath();
    
        var index = 0;
        var cols = srcGrid.cols;
        var midCol = Math.floor(srcGrid.cols / 2) + 1;
        for (var row = 1, midRow = Math.floor(srcGrid.rows / 2) + 1; row < midRow; row++) {
            for (var col = 1; col < midCol; col++) {
                index = getRowColIndex(row, col, cols);
                drawLine(srcGrid.xGrid[index], srcGrid.yGrid[index], dstGrid.xGrid[index], dstGrid.yGrid[index]); 
            } 
        } 
    }
    
    var stretchJustBegun = false;
    var stretchPointX = -1;
    var stretchPointY = -1;
    var stretchStartX = -1;
    var stretchStartY = -1;
    var timestamps = [];
    var timings = [];
    
    function resetTimeIt() {
        timestamps = [];
        timings = [];
    }
    
    function timeIt(desc) {
        timings.push(desc);
        timestamps.push(new Date().getTime());
    }
    
    function debugTimings() {
        var str = "";
        for(var i = 0, n = (timings.length - 1); i < n; i++) {
            str+="---- "+timings[i] +" - " + timings[i + 1]+" = "+(timestamps[i+1] - timestamps[i])+"ms</br>";
        }
        str+="---- total = "+(timestamps[timestamps.length - 1] - timestamps[0])+"ms</br>";
        debug(str);
    }
    
    function dist(x1, y1, x2, y2) {
        return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    }
    
    function alignXToCol(xGrid, col, rows, cols, val) {
        var minX = col; // * cols);
        for(var mx = minX, num = xGrid.length; mx < num; mx+=cols) {
            xGrid[mx] = val;
        }
    }
    
    function alignYToRow(yGrid, row, rows, cols, val) {
        var minY = (row * cols);
        for(var my = minY, num = minY + cols; my < num; my++) {
            yGrid[my] = val;
        }
    }
    
    function copyGrid(srcGrid, dstGrid) {
        var src = srcGrid.xGrid;
        var dst = dstGrid.xGrid;
        var num = srcGrid.rows * srcGrid.cols;
        for(var i = 0; i < num; i++) {
            dst[i] = src[i];
        }
        src = srcGrid.yGrid;
        dst = dstGrid.yGrid;
        for(var i = 0; i < num; i++) {
            dst[i] = src[i];
        }
    }
    
    function generate3x3Mesh(ssX, ssY, x, y, srcGrid, dstGrid) {
        alignXToCol(srcGrid.xGrid, 1, srcGrid.rows, srcGrid.cols, ssX);
        alignYToRow(srcGrid.yGrid, 1, srcGrid.rows, srcGrid.cols, ssY);
        
        alignXToCol(dstGrid.xGrid, 1, dstGrid.rows, dstGrid.cols, ssX);
        alignYToRow(dstGrid.yGrid, 1, dstGrid.rows, dstGrid.cols, ssY);
    
        dstGrid.xGrid[4] = srcGrid.xGrid[4] + (x - ssX);  // x;
        dstGrid.yGrid[4] = srcGrid.yGrid[4] + (y - ssY);  // y;    
    }
    
    function getRowColIndex(r, c, cols) {
        return ((r * cols) + c);
    }
    
    function warpUp(i, j, N, M, xOld, yOld, xNew, yNew, dstGrid) {
        var ix = getRowColIndex(i, j, M);
        var xc = dstGrid.xGrid[ix];
        var yc = dstGrid.yGrid[ix];
        
        var ratio = (yc / yOld);
        var xcNew = (xNew * ratio + xc*(1 - ratio));
        var ycNew = yNew * ratio;
        dstGrid.xGrid[ix] = xcNew;
        dstGrid.yGrid[ix] = ycNew;
        //debug("up: ("+i+","+j+") -> "+ix+" = ("+xc+","+yc+") of ("+xOld+","+yOld+") * " +ratio+" = ("+ xcNew+","+ycNew+") ");
    }
    
    function warpDown(i, j, N, M, xOld, yOld, xNew, yNew, xLim, yLim, dstGrid, dbg) {
        var ix = getRowColIndex(i, j, M);
        var xc = dstGrid.xGrid[ix];
        var yc = dstGrid.yGrid[ix];
        
        var ratio = ((yLim - yc) / (yLim - yOld));
        var xcNew = (xNew * ratio + xc*(1 - ratio));
        var ycNew = (yNew * ratio + yLim * (1 - ratio));
        dstGrid.xGrid[ix] = xcNew;
        dstGrid.yGrid[ix] = ycNew;
        if(dbg && (dbg.indexOf("5") >= 0)) drawLine(xc, yc, xcNew, ycNew, 1, 1);
        //debug("down: ("+i+","+j+") -> "+ix+" = ("+xc+","+yc+") of ("+xOld+","+yOld+") * " +ratio+" = ("+ xcNew+","+ycNew+") ");
    }
    
    function warpLeft(i, j, N, M, xOld, yOld, xNew, yNew, dstGrid) {
        var ix = getRowColIndex(i, j, M);
        var xc = dstGrid.xGrid[ix];
        var yc = dstGrid.yGrid[ix];
        
        var ratio = (xc / xOld);
        var xcNew = (xNew * ratio);
        var ycNew = yNew * ratio + yc*(1 - ratio);
        dstGrid.xGrid[ix] = xcNew;
        dstGrid.yGrid[ix] = ycNew;
        //debug("left: ("+i+","+j+") -> "+ix+" = ("+xc+","+yc+") of ("+xOld+","+yOld+") * " +ratio+" = ("+ xcNew+","+ycNew+") ");
    }
    
    function warpSlant(i, j, N, M, xOld, yOld, xNew, yNew, xAnchor, yAnchor, dstGrid, dbg) {
        var ix = getRowColIndex(i, j, M);
        var xc = dstGrid.xGrid[ix];
        var yc = dstGrid.yGrid[ix];
        var lineOld = new GeometricLine(xOld, yOld, xc, yc);
        var xIntercept = 0;
        var yIntercept = 0;
        if(xAnchor && yAnchor) {
            xIntercept = yAnchor;
            yIntercept = xAnchor;
        }
        else {
            xIntercept = lineOld.yatx(0);  //try xintercept first
            yIntercept = lineOld.xaty(0);                
        }
    
        var ratio = 0;
        var xcNew = 0;
        var ycNew = 0;
    
        if(dbg) ctx.strokeStyle = "#0000FF";
        if(dbg && (dbg.indexOf("1") >= 0)) drawLine(xOld, yOld, xc, yc, 1, 1);
        
        if(xIntercept < 0) {
            ratio =  dist(yIntercept, yAnchor, xc, yc) / dist(yIntercept, yAnchor, xOld, yOld);
            debug("line="+lineOld.toString() +" yIntercept="+yIntercept+","+yAnchor+" ratio="+ratio);
            xcNew = (xNew * ratio) + (yIntercept*(1 - ratio));
            ycNew = (yNew * ratio) + (yAnchor*(1 - ratio));;
    
            if(dbg && (dbg.indexOf("2") >= 0)) drawLine(xc, yc, xOld, yOld, 1, 1);
            if(dbg && (dbg.indexOf("3") >= 0)) drawLine(yIntercept, yAnchor, xc, yc, 1, 1);
            if(dbg && (dbg.indexOf("4") >= 0)) drawLine(yIntercept, yAnchor, xNew, yNew, 1, 1);
        }
        else {
            ratio = dist(xAnchor, xIntercept, xc, yc) / dist(xAnchor, xIntercept, xOld, yOld);
            debug("line:"+lineOld.toString() +" xIntercept="+xAnchor+","+xIntercept+" ratio="+ratio);
            xcNew = (xNew * ratio) + (xAnchor*(1 - ratio));
            ycNew = (yNew * ratio) + (xIntercept*(1 - ratio));
            
            if(dbg && (dbg.indexOf("2") >= 0)) drawLine(xc, yc, xOld, yOld, 1, 1);
            if(dbg && (dbg.indexOf("3") >= 0)) drawLine(xAnchor, xIntercept, xc, yc, 1, 1);
            if(dbg && (dbg.indexOf("4") >= 0)) drawLine(xAnchor, xIntercept, xNew, yNew, 1, 1);
        }
    
        if(dbg && (dbg.indexOf("5") >= 0)) drawLine(xc, yc, xcNew, ycNew, 2, 2);
        dstGrid.xGrid[ix] = xcNew;
        dstGrid.yGrid[ix] = ycNew;
    }
    
    function GeometricLine(x1, y1, x2, y2) {
        this.x1 = x1;
        this.y1 = y1;
        this.x2 = x2;
        this.y2 = y2;
        
        //y = mx + c
        this.m = (y2 - y1)/(x2 - x1);
        this.c = y1  - (this.m * x1);
        //debug("m="+this.m+" c="+this.c);    //+"="+(y2  - (this.m * x2)));
        
        this.xaty = function(y) {
            return ((y - this.c)/this.m);
        }
        
        this.yatx = function(x) {
            return ((x*this.m) + this.c);
        }
        
        this.toString = function() {
            return ("[y="+this.m+".x + "+this.c+"], ("+x1+","+y1+"), ("+x2+","+y2+")");
        }
    }
    
    function generateNxMMesh(N, M, ssX, ssY, x, y, xwin, ywin, w, h, srcGrid, dstGrid) {
        if((N < 5) || (M < 5)) {
            throw ("N and M must be > 5 (N="+N+", M="+M+")...");
        }
        var limN = N;
        var limM = M;
        //let the middle be the ssX/Y
        var midN = Math.floor(limN/2); 
        var midM = Math.floor(limM/2);
    
        //and arrange the rest equidistantly around midN and midM
        var stretchDeltaXPre = (ssX / midM);
        for(var i = 1; i <= midM; i++) {
            var nextX = (i * stretchDeltaXPre);
            alignXToCol(srcGrid.xGrid, i, srcGrid.rows, srcGrid.cols, nextX);
        }
        
        var stretchXPost = x;
        var stretchDeltaXPost = ((w - stretchXPost) / (limM - midM - 1));
        for(var i = (midM + 1); i < limM; i++) {
            stretchXPost += stretchDeltaXPost;
            alignXToCol(srcGrid.xGrid, i, srcGrid.rows, srcGrid.cols, stretchXPost);
        }
    
        var stretchDeltaYPre = (ssY / midN);
        for(var i = 1; i <= midN; i++) {
            var nextY = (i * stretchDeltaYPre);
            alignYToRow(srcGrid.yGrid, i, srcGrid.rows, srcGrid.cols, nextY);
        }
    
        var stretchYPost = y;
        var stretchDeltaYPost = ((h - stretchYPost) / (limN - midN - 1));
        for(var i = (midN + 1); i < limN; i++) {
            stretchYPost += stretchDeltaYPost;
            alignYToRow(srcGrid.yGrid, i, srcGrid.rows, srcGrid.cols, stretchYPost);
        }
    
        copyGrid(srcGrid, dstGrid);
    
        //stretch them out
        var stretchPointIx = getRowColIndex(midN, midM, M);
        var xLim = xwin;
        var yLim = ywin;
        var xOld = srcGrid.xGrid[stretchPointIx];
        var yOld = srcGrid.yGrid[stretchPointIx];
        var xDif = (x - ssX);
        var yDif = (y - ssY);
        var xNew = xOld + xDif;  // x;
        var yNew = yOld + yDif;  // y;
        
        //traverse 4 directions
        //UP
        for(var i = midN - 1; i > 0; i--) {
            warpUp(i, midM, N, M, xOld, yOld, xNew, yNew, dstGrid);
        }
        
        //LEFT
        for(var j = midM - 1; j > 0; j--) {
            warpLeft(midM, j, N, M, xOld, yOld, xNew, yNew, dstGrid);
        }
    
        //DOWN
        for(var i = midN + 1; i < (limN - 1); i++) {
            warpDown(i, midM, N, M, xOld, yOld, xNew, yNew, w, h, dstGrid);
        }
        
        //RIGHT
        var ixAnchor = getRowColIndex(midN, (M - 1), M);
        var xAnchor = srcGrid.xGrid[ixAnchor];
        var yAnchor = srcGrid.yGrid[ixAnchor];
        for(var j = midM + 1; j < (M - 1); j++) {
            warpSlant(midN, j, N, M, xOld, yOld, xNew, yNew, xAnchor, yAnchor, dstGrid, "");
        }
        
        //do those in between
        //UP+LEFT = 4th quadrant
        for(var i = midN - 1; i > 0; i--) {
            for(var j = midM - 1; j > 0; j--) {
                warpSlant(i, j, N, M, xOld, yOld, xNew, yNew, 0, 0, dstGrid);
            }
        }
        
        //DOWN+LEFT-to-RIGHT = 3rd and 2nd qudrant
        for(var j = 1; j < (M - 1); j++) { //LEFT
            if(j == midM) {
                continue;
            }
            var ixAnchor = getRowColIndex((N - 1), j, M);
            var xAnchor = srcGrid.xGrid[ixAnchor];
            var yAnchor = srcGrid.yGrid[ixAnchor];
            var ixFrom = getRowColIndex(midN, j, M);
            var xFrom  = srcGrid.xGrid[ixFrom];
            var yFrom  = srcGrid.yGrid[ixFrom];
            for(var i = (midN + 1); i < (N - 1); i++) { //DOWN
                var ixTo = getRowColIndex(midN, j, M);
                var xTo    = dstGrid.xGrid[ixTo];
                var yTo    = dstGrid.yGrid[ixTo];
                //debug("down+left+right i="+i+" j="+j);
                warpDown(i, j, N, M, xFrom, yFrom, xTo, yTo, xAnchor, yAnchor, dstGrid);
            }
        }
    
        //UP+RIGHT = 1st quadrant
        for(var j = midM + 1; j < (M - 1); j++) {   //RIGHT
                var ix = getRowColIndex(midN, j, M);
                var xFrom  = srcGrid.xGrid[ix];
                var yFrom  = srcGrid.yGrid[ix];
                var xTo    = dstGrid.xGrid[ix];
                var yTo    = dstGrid.yGrid[ix];
            for(var i= midN - 1; i > 0; i--) { //UP
                //debug("up+right i="+i+" j="+j);
                warpUp(i, j, N, M, xFrom, yFrom, xTo, yTo, dstGrid, "34");
            }
        }
    
        //debug("limN="+limN+" limM="+limM+" midN="+midN+" midM="+midM+" stretchPointIx="+stretchPointIx+"...");
        dstGrid.xGrid[stretchPointIx] = xNew;
        dstGrid.yGrid[stretchPointIx] = yNew;    
    }
    
    var imgBackup = null;
    
    function stretchContent1D(x, y, recurse) {
        var distStretched = dist(stretchPointX, stretchPointY, x, y); 
        debug("distStretched = "+distStretched);
        stretchPointX = x;
        stretchPointY = y;
        var w = canvasElement.width;   //winWidth  - 15;
        var h = canvasElement.height;   //winHeight - 15;
    
        if(imgBackup == null) {
            //debug("Grabbing img backup: "+ w+", "+h);
            showTouchPoint(0, 0, true); //hide touch point first
            //imgBackup = ctx.getImageData(0, 0, w, h); 
        }
        
        //reset content to remove traces previous stretch
        if(!recurse) {
            ctx.putImageData(imgContent, 0, 0);
        }
    
        var offset = 0;
        var pt = 0;
        if(offsetX > 0) {
            offset = offsetX;
            pt = x + 5;
            //do vertical direction first
            //if(!recurse) stretchContent1D(-1, y, true);
        }
        else if(offsetY > 0) { 
            offset = offsetY;
            pt = y + 5;
        }
        else {
            return;
        }
    
        var stretchPoints = [];            
        var deltaStretch = Math.floor(pt / offset);
        for(var i = 0; i < offset; i++) {
            stretchPoints.push((i + 1) * deltaStretch);
        }
        debug("distStretched = "+distStretched+" x="+x+" y="+y+" pt="+pt+" offset="+offset+" stretchPoints="+stretchPoints);
        //grab slices between stretchpoints and repeat them
        if(offsetX > 0) {
            for(var i = (stretchPoints.length - 1); i > 0; i--) {
                var imgSlice = ctx.getImageData(stretchPoints[i], 0, w - stretchPoints[i] - 1, h);
                //var imgSlice = ctx.getImageData(stretchPoints[i], 0, stretchPoints[i] + i, h);
                ctx.putImageData(imgSlice, stretchPoints[i]+1, 0);
                /*if(document.getElementById("show1Dmesh").checked) {
                    ctx.strokeStyle = "#BBBBBB";
                    drawLine(stretchPoints[i] + 1, 0, stretchPoints[i] + 1, h, 0, 0);
                }*/
            }
        }
        else if(offsetY > 0) {
            for(var i = (stretchPoints.length - 1); i > 0; i--) {
                var imgSlice = ctx.getImageData(0, stretchPoints[i], w, h - stretchPoints[i] - 1);
                //var imgSlice = ctx.getImageData(0, stretchPoints[i], w, stretchPoints[i] + i);
                ctx.putImageData(imgSlice, 0, stretchPoints[i]+1);
                /*if(document.getElementById("show1Dmesh").checked) {
                    ctx.strokeStyle = "#BBBBBB";
                    drawLine(0, stretchPoints[i] + 1, w, stretchPoints[i] + 1, 0, 0);
                }*/
            }
        }
    }
    
    var unstretchSteps = 5;
    var unstretchCount = 0;
    var unstretchPointX = 0;
    var unstretchPointY = 0;
    function unstretchContent1D(x, y, isStarting) {
        var distStretched = dist(stretchPointX, stretchPointY, stretchStartX, stretchStartY);
        if(isStarting) {
            unstretchCount = unstretchSteps;
            unstretchPointX = stretchPointX;
            unstretchPointY = stretchPointY;
            unstretchContent1D(x, y, false);
        }
        else if(unstretchCount > 0) {
            unstretchCount--;
            //intermediate reverse stretch
            var unstretchX = (((unstretchSteps - unstretchCount) * stretchStartX) + (unstretchCount * unstretchPointX))/unstretchSteps;
            var unstretchY = (((unstretchSteps - unstretchCount) * stretchStartY) + (unstretchCount* unstretchPointY))/unstretchSteps;
            var str = "distStretched="+distStretched+", unstretching: "+stretchPointX+","+stretchPointY+" -> "+unstretchX+","+unstretchY+" ->  "+stretchStartX+","+stretchStartY+".";
            stretchContent1D(unstretchX, unstretchY);
            debug(str);
            setTimeout(unstretchContent1D, 10);
        }
        else {
            if(imgBackup != null) {
                //ctx.putImageData(imgBackup, 0, 0);
                drawContent(0, 0);
                imgBackup = null;
            }
            stretchPointX = -1;
            stretchPointY = -1;
            stretchStartX = -1;
            stretchStartY = -1;
            stretchJustBegun = false;
            setTimeout(function(){ drawContent(0, 0); }, 10);
        }
    }
    
    var inPixels = null;
    var outPixels = null;
    var useWebGL = false;
    function stretchContent2D(x, y, forceWarp) {
        if(!x) {
            x = stretchPointX;  //mouseX - startX  + contentElement.scrollLeft;
            y = stretchPointY   //mouseY - startY  + contentElement.scrollTop;
        }
    
        var distStretched = dist(stretchPointX, stretchPointY, x, y); 
        debug("distStretched = "+distStretched);
        stretchPointX = x;
        stretchPointY = y;
    
        if(!forceWarp && (stretchJustBegun || (distStretched > 0))) {
            stretchJustBegun = false;
            //to avoid too many expensive warps, stretch only when user has slowed down
            // and skip the first stretch
            setTimeout(stretchContent2D, 10);
            return;
        }
    
        resetTimeIt();
        timeIt("start");
    
        var w = activeWidth; 
        var h = activeHeight; 
        //var w = winWidth;
        //var h = winHeight;
        //var w = 3 * stretchStartX;
        timeIt("init");
    
        if(imgBackup == null) {
            //debug("Grabbing img backup: "+ w+", "+h);
            showTouchPoint(0, 0, true); //hide touch point first
            imgBackup = ctx.getImageData(0, 0, w, h); 
        }
        //timeIt("cap");
        
        var cols = 7;
        var rows = 7;
    
        var srcGrid = new WarpGrid(rows, cols, w, h);
        var dstGrid = new WarpGrid(rows, cols, w, h);
        timeIt("warpinit");
        
        if((rows == cols) && (cols == 3)) {
            generate3x3Mesh(stretchStartX, stretchStartY, x, y, srcGrid, dstGrid);
        }
        else {
            generateNxMMesh(rows, cols, stretchStartX, stretchStartY, x, y, winWidth, winHeight, w, h, srcGrid, dstGrid);
        }
        
        //debug("Warping to " + x+","+y+" srcgrid=["+srcGrid.xGrid+" / "+ srcGrid.yGrid+"] dstgrid=["+dstGrid.xGrid+" / "+ dstGrid.yGrid+"]");
        timeIt("meshgen");
        
        var imgIn = imgContent;
        //var imgIn = imgBackup;
        //var imgIn = ctx.getImageData(0, 0, w, h); 
        //var imgIn = ctx.createImageData(imgBackup); 
        var imgOut = ctx.createImageData(w, h); 

        if(!useWebGL) {
            inPixels = newIntArray(imgIn.data.length / 4);
            outPixels = newIntArray(inPixels.length);
            timeIt("prepack");
            packToIntArray(imgIn.data, inPixels);
            timeIt("pack");            
            debug("Warping to " + x+","+y+" srcgrid=["+srcGrid.xGrid+" / "+ srcGrid.yGrid+"] dstgrid=["+dstGrid.xGrid+" / "+ dstGrid.yGrid+"]");
            timeIt("prewarp");
            dstGrid.warp(inPixels, w, h, srcGrid, dstGrid, outPixels);
            timeIt("warp");
            unpackFromIntArray(outPixels, imgOut.data);
            timeIt("unpack");
        }
        else {
            packToTextureBuffer(imgIn.data, txtrBufferIn);
            dstGrid.warpGL(txtrBufferIn, w, h, srcGrid, dstGrid, txtrBufferOut);
            unpackFromTextureBuffer(txtrBufferOut, imgOut.data);
        }
        ctx.putImageData(imgOut, 0, 0);
        timeIt("paint");
    
        if(document.getElementById("showmesh").checked) {
            paintGrid(srcGrid, "#FF0000", 0);
            paintGrid(dstGrid, "#00FF00", 0);
        }
        debugTimings();
    }
    
    function unstretchContent2D(x, y, isStarting) {
        var distStretched = dist(stretchPointX, stretchPointY, stretchStartX, stretchStartY);
        if(isStarting) {
            //intermediate reverse stretch
            var unstretchX = (stretchStartX + stretchPointX)/2;
            var unstretchY = (stretchStartY + stretchPointY)/2;
            var str = "distStretched="+distStretched+", unstretching: "+stretchPointX+","+stretchPointY+" -> "+unstretchX+","+unstretchY+" ->  "+stretchStartX+","+stretchStartY+".";
            stretchContent2D(unstretchX, unstretchY, true);
            debug(str);
            setTimeout(unstretchContent2D, 50);
        }
        else {
            if(imgBackup != null) {
                //ctx.putImageData(imgBackup, 0, 0);
                drawContent(0, 0);
                imgBackup = null;
            }
            stretchPointX = -1;
            stretchPointY = -1;
            stretchStartX = -1;
            stretchStartY = -1;
            stretchJustBegun = false;
            setTimeout(function(){ drawContent(0, 0); }, 10);
        }
    }
</script>
<style>
    #leftnav {
        font-size:0.85em; 
        #width:150px;
    }
    
    #leftnav ul {
        margin:0px; 
        padding:0px;
        border-bottom: 1px solid #AAAAAA;
        height: 100%;
    
    }
    
    #leftnav li {
    list-style: none;
    color: #666666;
    cursor: pointer;
    display: block;
    height: 25px;
    line-height: 25px;
    text-indent: 10px;
    text-decoration:none;
    border: 1px solid #AAAAAA;
    border-bottom: 0px;
    width:100%;
    }

    #kanvas {
    cursor : pointer;
    }

    #kanvas : active, #kanvas : focus { 
    cursor: none;
    }

    #infotbl {
        font-size:0.85em; 
    }
    
    #infotbl td, #infotbl th {
        padding: 3px;
        text-align: right;
        valign: top;
        width: 40px;
    }

</style>    
</head>
<body onload="init()" valign="top" halign="center">
<div id="outer">
    <div style="position:relative; z-index: 1; left:0px; top:0px; overflow:none; float:left; padding-right:1em; "> 
        <div id="bg" style="width:255px; height:366px; background:#fff;">
        <!-- /div>
        <div id="content" style="position:absolute; left:0px; top:0px; width:255px; height:366px; overflow:scroll"-->
            <canvas id="kanvas" style="position:absolute; left:0px; top:0px;" width="500" height="520">Your browser does not support the canvas tag</canvas>
        </div>
    </div>
    <div style="position:relative; z-index: 1; left:255px; top:0px; float:left; padding-right:2em">
        <div id="leftnav">
            <b>Display</b>
            <ul>
            <li>
                <input type="radio" name="dispgroup" id="imgDisplay" value="imgDisplay" onChange="changeDisplay('image')" checked>Image Display
            </li>
            <li>
                <input type="radio" name="dispgroup" id="txtDisplay" value="txtDisplay" onChange="changeDisplay('text')">Text Display
            </li>
            <li>
                <input type="radio" name="dispgroup" id="mixDisplay" value="mixDisplay" onChange="changeDisplay('mixed')">Text + Image Display
            </li>
            </ul>
            <br/>

            <b>Mode</b>
            <ul>
            <li>
                <input type="radio" name="modegroup" id="stretch1DChk" value="stretch1D" onChange="changeMode('stretch1D')"> 1D Stretch
                <!-- input type="checkbox" id="show1Dmesh">Show Mesh -->
            </li>
            <li>
                <input type="radio" name="modegroup" id="stretch2DChk" value="stretch2D" onChange="changeMode('stretch2D')"> 2D Stretch
                <input type="checkbox" id="showmesh">Show Mesh
            </li>
            <li>
                <input type="radio" name="modegroup" id="stretchGL1DChk" value="stretchGL1D" onChange="changeMode('stretchGL1D')"> WebGL 1D Stretch
            </li>
            <li>
                <input type="radio" name="modegroup" id="stretchGL2DChk" value="stretchGL2D" onChange="changeMode('stretchGL2D')"> WebGL 2D Stretch
            </li>
            </ul>
            <input type="checkbox" id="showtouch" checked>Show Touch<br/>
            <input type="checkbox" id="showdebug" onChange="showDebug()">Show Debug Log
        </div>
        <br/>
        <table border="0" id="infotbl">
        <tr><td></td>            <td><b>X</b></td>              <td><b>Y</b></td></tr>
        <tr><td>start</td>       <td id="startX">0</td>         <td id="startY">0</td></tr>
        <tr><td>offset</td>      <td id="offsetX">0</td>        <td id="offsetY">0</td></tr>
        <tr><td>mouse</td>       <td id="mouseX">0</td>         <td id="mouseY">0</td></tr>
        <tr><td>scroll</td>      <td id="scrollTop">0</td>      <td id="scrollLeft">0</td></tr>
        <tr><td>stretchStart</td><td id="stretchStartX">0</td>  <td id="stretchStartY">0</td></tr>
        <tr><td>stretchPoint</td><td id="stretchPointX">0</td>  <td id="stretchPointY">0</td></tr>
        <tr><td>currentMode</td> <td id="currentMode" colspan="2"></td></tr>
        </table>
    </div>
    <div style="top:0px; float: right; float: left; padding-right:1em">
        <div id="warning" style="position:relative; left:255px; top:0px; width:400px; height:100px; border: 1px solid #AAAAAA; ">
        </div>
        <div id="debug"   style="position:relative; left:255px; width:400px; height:300px; overflow:scroll; border: 1px solid #AAAAAA; visibility:hidden; ">
            <div id="debugCell">DEBUG</div>
        </div>
    </div>
</div>
</body>
</html>
